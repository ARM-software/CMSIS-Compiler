/*=======0=========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1====*/
/**
\mainpage
The software component \b Compiler allows you to retarget I/O functions of the standard C run-time library.

This documentation contains the following sections:

- \ref Retarget_Overview : provides an overview about the Compiler software component, the technical background and the
  channels that can be retargeted.
- \ref Retarget_Details : explains the available options for retargeting the channels and describes the available user code
  templates.
- The [I/O Retarget example project](../example/README.md) shows how to retarget the output to a UART on an Arm Virtual
  Hardware model.
- \ref Retarget_Files : contains the \ref retarget_io_c "retarget_io.c" file and the user code template files for the
  different channel/variant use cases.

\note

The \b Compiler component is available for
<a href="https://developer.arm.com/Tools%20and%20Software/Arm%20Compiler%20for%20Embedded" target="_blank">Arm Compiler for Embedded</a>
and the <a href="https://developer.arm.com/Tools%20and%20Software/GNU%20Toolchain" target="_blank">Arm GNU Toolchain (GCC)</a>.
IAR Compiler support will be added in a future revision of the pack. 
*/

/* ========================================================================================================================== */
/**
\page Retarget_Overview Overview
Application code frequently uses standard I/O library functions, such as \c printf(), \c scanf(), or \c fgetc() to perform
input/output operations. The structure of these functions in the standard Arm Compiler C run-time library is:

\image html "struct_comp_function.png"  "Function Structure"

High-level and low-level functions are not target-dependent and use the system I/O functions to interface with hardware.
However, the high-level library functions perform input/output by calling the low-level ones,
which themselves call the system I/O functions, which are target-dependent.

To retarget input/output, you can:
 - \b Avoid the \em high-level library functions.
 - \b Redefine the \em low-level library functions.
 - \b Redefine the \em system \em I/O functions.

Whether redefining the low-level library functions or the system I/O functions is a better solution, depends on your use
case. For example, UARTs write a single character at a time and the default \c fputc() uses buffering, so redefining this
function without a buffer might suit a UART. However, where buffer operations are possible, redefining the system I/O
functions would probably be more appropriate.

The page \ref Retarget_Details explains the details about how retargeting is done using the Arm Compiler component.

Semihosting
===========

Semihosting is a mechanism that enables code running on an Arm target to communicate and use the input/output facilities on
a host computer that is running a debugger. Semihosting is not supported by all debuggers (see note).

Examples of these facilities include keyboard input, screen output, and disk I/O. For example, you can use this mechanism to
enable functions in the C library, such as `printf()` and `scanf()`, to use the screen and keyboard of the host instead of
having a screen and keyboard on the target system.

This is useful because development hardware often does not have all the input and output facilities of the final system.
Semihosting enables the host computer to provide these facilities.

Semihosting is implemented by a set of defined software instructions, for example, SVCs, that generate exceptions from
program control. The application invokes the appropriate semihosting call and the debug agent then handles the exception
 The debug agent provides the required communication with the host.

The semihosting interface is common across all debug agents provided by Arm. Semihosted operations work when you are
debugging applications on your development platform, as shown in the following figure:

\image html "semihosting.png"  "Semihosting"

\note 

Semihosting is not supported by µVision. In case you have to write your own retarget code, ensure that no semihosting
functions of the C library get linked into your application. This is done by importing the symbol
\c __use_no_semihosting_swi. This can be done in any C or assembler source file in your project. In a C
module, use the \c \#pragma directive:

\code
#pragma import(__use_no_semihosting_swi)
\endcode

In an assembler module, use the \c IMPORT directive:
\code
IMPORT __use_no_semihosting_swi
\endcode
<br/>
*/

/* ========================================================================================================================== */
/**
\page Retarget_Details Retargeting Channels and Variants

\section Retarget_Channels Channels for Retargeting

The software component <b>Compiler::I/O</b> can retarget the input/output functions to following channels:

I/O Channel |  Description
------------|--------------------
\b File     | Channel for all file related operations (\c fscanf, \c fprintf, \c fopen, \c fclose, etc.)
\b STDERR   | Standard error stream of the application to output diagnostic messages.
\b STDIN    | Standard input stream going into the application (\c scanf etc.).
\b STDOUT   | Standard output stream of the application (\c printf etc.).
\b TTY      | Teletypewriter, which is the last resort for error output.

Most retargeting channels have various \ref Retarget_Variants.

\section Retarget_Variants Retarget Variants

The variant selection allows you to change the target hardware interface of the I/O channel. The following variants are
available:

|Variant           | Description
|------------------|--------------------
|\b File \b System | Use a file system component for file related operations.
|\b Breakpoint     | When the I/O channel is used, the application stops with <a href="https://developer.arm.com/documentation/100073/latest/The-Arm-C-and-C---Libraries/Support-for-building-an-application-with-the-C-library/Using-the-C-and-C---libraries-with-an-application-in-a-semihosting-environment?lang=en" target="_blank">BKPT</a> instruction. No additional code is required.|
|\b ITM            | Use <a href="https://developer.arm.com/documentation/ddi0314/h/Instrumentation-Trace-Macrocell?lang=en" target="_blank">Instrumentation Trace Macrocell (ITM)</a> for I/O communication via the debugger (only available for Cortex-M3/M4/M7/M33/M55/M85 processors).<br/> Usually, data is shown in a dedicated window.<br/> No additional code is required to output or input data through the ITM channel. However, you have to configure the ITM channel for tracing.|
|\b User           | Retarget I/O functions to a user defined interface (such as \ref uct_usart "USART", \ref uct_keyboard "keyboard", \ref uct_display "graphics display", or a \ref uct_template "application specific").<br/>See \subpage variant_User for further details.|
|\b EVR            | STDIO can also be redirected using the <a href="https://arm-software.github.io/CMSIS-View/main/evr.html" target="_blank">Event Recorder</a> (especially interesting for targets without ITM (such as Cortex-M0/M0+/M23)). |

\note

- Depending on the selected variant, certain \c \#defines are set in the header file \b RTE_Components.h that enable the
  appropriate code sections in the \ref retarget_io_c " retarget_io.c file".
- Retargeting \b STDOUT using the \em EVR variant is available for all Cortex-M based devices.
- The <a href="https://developer.arm.com/documentation/100073/latest/The-Arm-C-Micro-library?lang=en" target="_blank">microlib</a> of
  Arm Compiler C run-time library interfaces to the hardware via low-level functions. It implements a reduced set of
  high-level functions and therefore does not implement system I/O functions. Thus, in case of using the microlib, you cannot
  redefine the system I/O functions. Using any of the features of the Arm Compiler component provides the
  <a href="https://developer.arm.com/documentation/101754/latest/armasm-Legacy-Assembler-Reference/armasm-Directives-Reference/ASSERT-directive?lang=en" target="_blank">assert</a> facility
  for microlib.
*/

/* ========================================================================================================================== */
/**
\page variant_User Retarget Variant "User"
The Compiler component variant \b User provides code templates that help you to implement the functionality.

In µVision, you can import the templates into a project using the context menu
\b Add \b New \b Item \b to \b Group from the Project window. Depending on your selection, you get templates that support
retargeting via display, USART, or keyboard. Also, a template for a custom implementation is available.

\image html "retarget_addTemplates.png" "Retargeting Code Templates"

\section uct_display Output via Display

You may use a <b>Graphics</b> component or write your own output routines. The following user code templates are available:

|Component | Name                 | File Name                                |
|----------|----------------------|------------------------------------------|
|I/O:STDOUT| STDOUT via Display   | \ref stdout_display_c "stdout_display.c" |
|I/O:STERR | STDERR via Display   | \ref stderr_display_c "stderr_display.c" |

\note
To have the full flexibility for retargeting different channels to different target hardware, each display user code template
contains a function to initialize the display. When using the same hardware for multiple channels, remove the initialization
function from one template and call the other function during the initialization of the device's peripherals.

\section uct_usart Input/Output via USART

You may use a
<a href="https://arm-software.github.io/CMSIS_5/develop/Driver/html/group__usart__interface__gr.html" target="_blank">CMSIS-Driver USART</a>
or write your own output routines. The following user code templates are available:

|Component | Name                 | File Name                           |
|----------|----------------------|-------------------------------------|
|I/O:STDOUT| STDOUT via USART     | \ref stdout_USART_c "stdout_USART.c"|
|I/O:STDIN | STDIN via USART      | \ref stdin_USART_c "stdin_USART.c"  |
|I/O:STERR | STDERR via USART     | \ref stderr_USART_c "stderr_USART.c"|

\note
To have the full flexibility for retargeting different channels to different target hardware, each USART user code template
contains a function to initialize the USART. When using the same hardware for multiple channels, the initialization functions
need to be merged in one single function. Call this function during the initialization of the device's peripherals.

\section uct_keyboard Input via Keyboard

You may use software components that support the keyboard functionality or write you own routines. For example, you may use
the HID class of a <b>USB Host</b> component to read data from a USB keyboard. The following user code template is available:

|Component | Name                 |File Name                                 |
|----------|----------------------|------------------------------------------|
|I/O:STDIN | STDIN via Keyboard   | \ref stdin_keyboard_c "stdin_keyboard.c" |

\section uct_template Input/Output via Template

Use these templates for custom interfaces that are not mentioned above. The following user code templates are available:

|Component | Name                 | File Name                          |
|----------|----------------------|------------------------------------|
|I/O:STDOUT| STDOUT User template | \ref stdout_user_c "stdout_user.c" |
|I/O:STDIN | STDIN User template  | \ref stdin_user_c "stdin_user.c"   |
|I/O:STERR | STDERR User template | \ref stderr_user_c "stderr_user.c" |
|I/O:TTY   | TTY User template    | \ref tty_user_c "tty_user.c"       |

<br/>
*/
