/* ========================================================================================================================== */
/**
\page Retarget_Examples Examples

The software pack <a href="https://www.keil.com/dd2/pack/#/Keil.Arm_Compiler" target="_blank"><b>Keil:Arm_Compiler</b></a>
contains several example projects that show how to do I/O retargeting. Use Pack Installer to copy the projects to your
working folder. Build the selected project and enter a debug session.

The following  example projects are available:

Example Project                  | Description
:--------------------------------|:-----------------------------------------
\subpage Retarget_Examples_Dsip  | Shows how to use a USB keyboard for STDIN and a TFT LCD for STDOUT.
\subpage Retarget_Examples_ITM   | Shows how to use ITM for STDOUT.
\subpage Retarget_Examples_UART  | Shows how to use a U(S)ART for STDOUT.
\subpage Retarget_Examples_er    | µVision simulator example that shows how to use Event Recorder for STDOUT.
*/

/* ========================================================================================================================== */
/**
\page Retarget_Examples_Dsip  Retarget Input via Keyboard and Output via Display

For development boards from Keil (for example MCB4300, MCB1800, MCBSTM32F200/400), example projects are available that show
how to use a USB keyboard for STDIN and a TFT LCD for STDOUT. These examples are usually called \b USB \b Host \b Keyboard
and can be found using Pack Installer:

\image html PI_USB_Keyboard.png "Pack Installer showing the USB Host Keyboard Example Project"

Copy the project to your harddrive and examine how the example works. This will be the base for the next steps that show how
to change the example to use \ref Retarget_Examples_ITM "ITM for STDOUT", and later a
\ref Retarget_Examples_UART "UART for STDOUT and STDIN".
*/

/* ========================================================================================================================== */
/**
\page Retarget_Examples_ITM  Retarget Output via ITM

Copy the \b USB \b Host \b Keyboard example application to your PC as described in \ref Retarget_Examples_Dsip. To change the
retarget option for \b STDOUT to \b ITM, open the \b Manage \b Run-Time \b Environment window and set the Variant as shown
here:

\image html "SelITMOutput.png" "Select ITM as Output Channel"

This will change the \c \#defines in the RTE_Components.h file and thus execute another code section in
\ref retarget_io_c "retarget_io.c". Adapting the code is not required. The code in the file \b stdout_display.c is now
disabled because of the new \c \#defines. Sending data via the ITM channel does not require additional code.

Configure your debug adapter for tracing and enable the ITM channel 0 as described in
<a href="http://www.keil.com/support/man/docs/ulinkpro/ulinkpro_tr_stimulusports.htm">ITM Stimulus Ports</a>.

Build the project, download it to the target, and start a debug session. Open the \b Debug \b (printf) \b Viewer window
(View -> Serial Windows -> Debug (printf) Viewer) to observe the application's output. Input is still coming from the USB
keyboard.

\image html "ITMOutput.png" "Output redirected to Debug (printf) Viewer"
*/

/* ========================================================================================================================== */
/**
\page Retarget_Examples_er  Retarget STDOUT via Event Recorder

Copy the \b SCVD \b printf \b Redirect \b Example application for the µVision Simulator to your PC using Pack Installer. This
simple application is already set to redirect printf output on an Arm Cortex-M0 to the Event Recorder.


To retarget STDOUT to the
<a href="../../EventRecorder/html/index.html">Event Recorder</a> in a user application, these steps are required:
 -# In the Manage Run-Time Environment window, set the component <b>Compiler:I/O:STDOUT</b> to use \b Variant \em EVR.
 -# Select the component <b>Compiler:Event Recorder</b> or use the \b Resolve button.
 \image html er_comp_selection.png
 -# In the user code, include \c EventRecorder.h and call the \c EventRecorderInitialize() function in main():
 \code
#include "cmsis_os2.h"                  // Arm::CMSIS:RTOS2:Keil RTX5
#include "stdio.h"
#include "EventRecorder.h"              // Keil.Arm Compiler::Compiler:Event Recorder

typedef struct {
  uint32_t hi;
  uint32_t low;
} MyType;

MyType mysymbol;

int main(void) {
  int       i;
  EventRecorderInitialize(EventRecordAll, 1);

  while (1) {
    for( i=0; i<=30; i++ ) {
      printf("The value of i is %d\n", i);
      mysymbol.hi = i*i;
      mysymbol.low = i;
    }
  }
}
 \endcode
 -# (For simulation only!) Open the target options dialog and add a Debug.ini file to simulate the DWT Cycle Counter:
 \code
MAP 0xE0001000, 0xE0001007 READ WRITE

signal void DWT_CYCCNT (void) {
  while (1) {
    rwatch(0xE0001004);
    _WWORD(0xE0001004, states);
  }
}

DWT_CYCCNT()
 \endcode

Build and run the project. Open the <b>Debug (printf) Viewer</b> window using View - Serial Windows - Debug (printf) Viewer.
The printf output will be shown here:

\image html debug_printf_output.png

If you are using the Event Recorder window at the same time, you will notice that it also shows the printf output, just
with hexadecimal display:

\image html er_printf_output.png

\note

- If your output is garbled, you might want to consider increasing the buffer size for the Event Recorder.
- The Event Recorder window will display missed events to notify you about buffer size problems.
\image html garbled_output.png
<br/>
*/

/* ========================================================================================================================== */
/**
\page Retarget_Examples_UART  Retarget Input and Output via UART

Copy the \b USB \b Host \b Keyboard example application to your PC as described in \ref Retarget_Examples_Dsip.

\section Retarget_Examples_UART_variants Variant Selection
To change the retarget option for \b STDIN and \b STDOUT to \b USART, open the \b Manage \b Run-Time \b Environment window
and set the \b Variants as shown here:

\image html "SelOutput.png" "Select USART as Input and Output Channel"

This will change the \c \#defines in the RTE_Components.h file and thus execute another code section in
\ref retarget_io_c "retarget_io.c".

\section Retarget_Examples_UART_uct Add User Code Templates for the USART
Use the context menu in the Project window to add user code template files to the source code. Right-click on the group
\b Source, select <b>Add new Items to Group</b>. Click on <b>User Code Templates</b>, expand the component <b>Compiler</b>,
and add the templates for STDIN and STDOUT via USART.

\image html "SelTemplatesUART.png" "Select Templates for UART Retargeting"

This adds the files \b stdin_usart.c and \b stdout_usart.c to the group \b Source. The files contain predefined functions
which need little modifications if you are using CMSIS-Driver for USARTs.

\section Retarget_Examples_UART_cmsis_driver Use CMSIS-Driver USART
But first, enable the CMSIS-Driver in the \b Manage
\b Run-Time \b Environment window:

\image html "CMSIS_Driver_USART.png" "Enable the CMSIS-Driver USART"

The \b Validation \b Output window might show related component dependencies. Click \b Resolve to automatically add the
required components to your project.

\section Retarget_Examples_UART_configure_USART Configure the USART Driver
Under \b Device, open the file \b RTE_Device.h and enable the correct USART (here: \b USART1). Configure the pins according to
your target hardware (refer to the board documentation for further details; here \b PB6/PB7):

\image html "RTE_Device_h.png" "Device Configuration using RTE_Device.h"

\section Retarget_Examples_UART_connect Connect the Retargeting Functions to the Correct Driver Instance
Open \b stdout_USART.c and \b stdin_USART.c. Use the \b Configuration \b Wizard view to set the correct hardware interface
(here: \b Driver_USART1) in both files:

\image html "Driver_Config_Wizard.png" "Driver Configuration using the Configuration Wizard"

\note
To have the full flexibility for retargeting different channels to different target hardware, each user code template
contains a function to initialize the underlying hardware. This is fine as long as you are not using the same hardware for
multiple channels.

\section Retarget_Examples_UART_code Adapt the Code
In this example, the USART is used for STDIN and STDOUT simultaneously. Thus, one of the initialization functions need to be
commented out and the content needs to be merged with the other one. Change to \b Text \b Editor mode for both files. In
\c stdout_USART.c comment out the function \c stdout_init (lines 62 to 83):

\code
//int stdout_init (void) {
//  int32_t status;

//  status = ptrUSART->Initialize(NULL);
//  if (status != Arm_DRIVER_OK) return (-1);

//  status = ptrUSART->PowerControl(Arm_POWER_FULL);
//  if (status != Arm_DRIVER_OK) return (-1);

//  status = ptrUSART->Control(Arm_USART_MODE_ASYNCHRONOUS |
//                             Arm_USART_DATA_BITS_8       |
//                             Arm_USART_PARITY_NONE       |
//                             Arm_USART_STOP_BITS_1       |
//                             Arm_USART_FLOW_CONTROL_NONE,
//                             USART_BAUDRATE);
//  if (status != Arm_DRIVER_OK) return (-1);

//  status = ptrUSART->Control(Arm_USART_CONTROL_TX, 1);
//  if (status != Arm_DRIVER_OK) return (-1);

//  return (0);
//}
\endcode

Copy the last call to the \b Control struct of the USART driver to the \c stdin_init function (line 62) in \c stdin_USART.c:

\code
int stdin_init (void) {
  int32_t status;

  status = ptrUSART->Initialize(NULL);
  if (status != Arm_DRIVER_OK) return (-1);

  status = ptrUSART->PowerControl(Arm_POWER_FULL);
  if (status != Arm_DRIVER_OK) return (-1);

  status = ptrUSART->Control(Arm_USART_MODE_ASYNCHRONOUS |
                             Arm_USART_DATA_BITS_8       |
                             Arm_USART_PARITY_NONE       |
                             Arm_USART_STOP_BITS_1       |
                             Arm_USART_FLOW_CONTROL_NONE,
                             USART_BAUDRATE);
  if (status != Arm_DRIVER_OK) return (-1);

  status = ptrUSART->Control(Arm_USART_CONTROL_RX, 1);
  if (status != Arm_DRIVER_OK) return (-1);

  status = ptrUSART->Control(Arm_USART_CONTROL_TX, 1);
  if (status != Arm_DRIVER_OK) return (-1);

return (0);
}
\endcode

The \c stdin_init() function needs to be called in \c main. Change the following line in the \c Keyboard.c file:

\code
extern int stdin_init (void);
\endcode

In \b main(), replace \c stdout_init() with \c stdin_init():

\code
:
SystemClock_Config();                      /* Configure the System Clock    */

stdout_init();                             /* Initialize printf output      */

ADC_Initialize          ();                /* Initialize A/D converter      */
:
\endcode

\section Retarget_Examples_UART_remove Remove old Template Files
Before building the project, remove the old user code templates from the target build. Right-click the files
\c stdin_keyboard.c and \c stdout_display.c, select \b Options \b for \b File, and disable \b Include \b in \b Target
\b Build:

\image html "FileOptions.png" "Remove Unnecessary User Code Template Files from Target Build"

\section Retarget_Examples_UART_run Run the Application
Build the project, configure for debugging, and download the application to the development board. Connect the development
board with an RS232 cable to a PC. Open a terminal program with the correct COM port setting and observe that a menu is
displayed. Enter a command via your keyboard and test the application:

\image html "Terminal_Output.png" "Input and Output on the Terminal with MCB1800"

\note If you do not see any output on the terminal, check the baud rate settings (9600 baud), COM port number, or verify that
      hte correct USB driver is used (in case you have a USB-Serial converter attached to the PC).
*/

